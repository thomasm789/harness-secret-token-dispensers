template:
  name: GCP OAuth Token Dispenser
  identifier: GCP_OAuth_Token_Dispenser
  versionLabel: "1"
  type: SecretManager
  tags: {}
  spec:
    shell: Bash
    delegateSelectors: []
    source:
      type: Inline
      spec:
        script: |-
          set -o pipefail

          # Define required variables directly from the secret manager
          CLIENT_EMAIL="<+secretManager.environmentVariables.client_email>"
          PRIVATE_KEY="<+secretManager.environmentVariables.private_key>"
          TOKEN_URI="<+secretManager.environmentVariables.token_uri>"

          # Ensure all necessary values are available
          if [[ -z "$CLIENT_EMAIL" || -z "$PRIVATE_KEY" || -z "$TOKEN_URI" ]]; then
              echo "Failed to retrieve necessary environment variables."
              exit 1
          fi

          # Define the JWT header and claim set as JSON objects
          HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
          CLAIM_SET=$(cat <<EOF
          {
            "iss": "$CLIENT_EMAIL",
            "scope": "https://www.googleapis.com/auth/cloud-platform",
            "aud": "$TOKEN_URI",
            "exp": $(($(date +%s) + 3600)),
            "iat": $(date +%s)
          }
          EOF
          )

          # Base64 encode the claim set
          CLAIM_SET_BASE64=$(echo -n "$CLAIM_SET" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')

          # Create the signature using the private key
          SIGNATURE=$(echo -n "$HEADER.$CLAIM_SET_BASE64" | \
              openssl dgst -sha256 -sign <(echo "$PRIVATE_KEY" | sed 's/\\n/\n/g') | \
              base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')

          # Form the JWT token
          JWT="$HEADER.$CLAIM_SET_BASE64.$SIGNATURE"

          # Request the access token
          RESPONSE=$(curl -s -X POST "$TOKEN_URI" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=$JWT")

          # Extract the access token manually from the JSON response
          ACCESS_TOKEN=$(echo "$RESPONSE" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)

          # Check if an access token was successfully obtained
          if [[ -z "$ACCESS_TOKEN" || "$ACCESS_TOKEN" == "null" ]]; then
              echo "Failed to get an access token"
              echo "Response: $RESPONSE"
              exit 1
          fi

          # Set the access token as the secret output
          secret="$ACCESS_TOKEN"
    environmentVariables:
      - name: client_email
        type: String
        value: <+input>
      - name: token_uri
        type: String
        value: <+input>
      - name: private_key
        type: String
        value: <+input>
    outputVariables: []
    outputAlias:
      key: ACCESS_TOKEN
      scope: Pipeline
    onDelegate: true
